@file:Suppress("LongMethod", "ComplexMethod")

package me.uport.sdk.ethrdid

import android.support.annotation.VisibleForTesting
import android.support.annotation.VisibleForTesting.PRIVATE
import com.uport.sdk.signer.Signer
import me.uport.sdk.core.ITimeProvider
import me.uport.sdk.core.SystemTimeProvider
import me.uport.sdk.core.bytes32ToString
import me.uport.sdk.core.hexToBytes32
import me.uport.sdk.core.toBase64
import me.uport.sdk.core.utf8
import me.uport.sdk.ethrdid.EthereumDIDRegistry.Events.DIDAttributeChanged
import me.uport.sdk.ethrdid.EthereumDIDRegistry.Events.DIDDelegateChanged
import me.uport.sdk.jsonrpc.JsonRPC
import me.uport.sdk.jsonrpc.JsonRpcException
import me.uport.sdk.universaldid.AuthenticationEntry
import me.uport.sdk.universaldid.DIDResolver
import me.uport.sdk.universaldid.DidResolverError
import me.uport.sdk.universaldid.PublicKeyEntry
import me.uport.sdk.universaldid.PublicKeyType
import me.uport.sdk.universaldid.PublicKeyType.Companion.Secp256k1SignatureAuthentication2018
import me.uport.sdk.universaldid.PublicKeyType.Companion.Secp256k1VerificationKey2018
import me.uport.sdk.universaldid.ServiceEntry
import org.kethereum.encodings.encodeToBase58String
import org.kethereum.extensions.hexToBigInteger
import org.kethereum.extensions.toHexStringNoPrefix
import org.walleth.khex.hexToByteArray
import org.walleth.khex.prepend0xPrefix
import org.walleth.khex.toHexString
import pm.gnosis.model.Solidity
import java.math.BigInteger
import java.util.*

/**
 * This is a DID resolver implementation that supports the "ethr" DID method.
 * It accepts ethr-dids or simple ethereum addresses and produces a document described at:
 * https://w3c-ccg.github.io/did-spec/#did-documents
 *
 * Example ethr did: "did:ethr:0xb9c5714089478a327f09197987f16f9e5d936e8a"
 */
open class EthrDIDResolver(
        private val rpc: JsonRPC,
        val registryAddress: String = DEFAULT_REGISTRY_ADDRESS,
        private val timeProvider: ITimeProvider = SystemTimeProvider
) : DIDResolver {

    override val method = "ethr"

    override fun canResolve(potentialDID: String): Boolean {
        //if it can be normalized, then it matches either an ethereum address or a full ethr-did
        return normalizeDid(potentialDID).isNotBlank()
    }

    /**
     * Resolves a given ethereum address or DID string into a corresponding [EthrDIDDocument]
     */
    override suspend fun resolve(did: String): EthrDIDDocument {
        val normalizedDid = normalizeDid(did)
        val identity = parseIdentity(normalizedDid)
        val ethrdidContract = EthrDID(identity, rpc, registryAddress, Signer.blank)
        val owner = ethrdidContract.lookupOwner(false)
        val history = getHistory(identity)
        return wrapDidDocument(normalizedDid, owner, history)
    }

    /**
     * Obtains the block number when the given identity was last changed, or [BigInteger.ZERO] if no change was ever made
     */
    @VisibleForTesting(otherwise = PRIVATE)
    suspend fun lastChanged(identity: String): String {
        val encodedCall = EthereumDIDRegistry.Changed.encode(Solidity.Address(identity.hexToBigInteger()))
        return try {
            rpc.ethCall(registryAddress, encodedCall)
        } catch (err: JsonRpcException) {
            throw DidResolverError("Unable to evaluate when or if the $identity was lastChanged because RPC endpoint responded with an error", err)
        }
    }

    /**
     * Builds a simple_list of events associated with the [identity] in the ether-did-registry contract that resides at [registryAddress]
     *
     * Since the Event classes are generated by bivrost-kotlin, they don't have a specific type so the simple_list id of type [Any]
     */
    @Suppress("TooGenericExceptionCaught")
    @VisibleForTesting(otherwise = PRIVATE)
    suspend fun getHistory(identity: String): List<Any> {
        val lastChangedQueue: Queue<BigInteger> = PriorityQueue<BigInteger>()
        val events = emptyList<Any>().toMutableList()
        lastChangedQueue.add(lastChanged(identity).hexToBigInteger())
        do {
            val lastChange = lastChangedQueue.remove()
            val logs = rpc.getLogs(registryAddress, listOf(null, identity.hexToBytes32()), lastChange, lastChange)
            logs.forEach {
                val topics: List<String> = it.topics
                val data: String = it.data

                try {
                    val event = EthereumDIDRegistry.Events.DIDOwnerChanged.decode(topics, data)
                    lastChangedQueue.add(event.previouschange.value)
                    events.add(event)
                } catch (err: Exception) { /*nop*/
                }

                try {
                    val event = EthereumDIDRegistry.Events.DIDAttributeChanged.decode(topics, data)
                    lastChangedQueue.add(event.previouschange.value)
                    events.add(event)
                } catch (err: Exception) { /*nop*/
                }

                try {
                    val event = EthereumDIDRegistry.Events.DIDDelegateChanged.decode(topics, data)
                    lastChangedQueue.add(event.previouschange.value)
                    events.add(event)
                } catch (err: Exception) { /*nop*/
                }

            }


        } while (lastChange != null && lastChange != BigInteger.ZERO)

        return events
    }

    /**
     * Wraps previously gathered info into a [EthrDIDDocument]
     */
    @VisibleForTesting(otherwise = PRIVATE)
    fun wrapDidDocument(ownerDID: String, ownerAddress: String, history: List<Any>): EthrDIDDocument {

        val pkEntries = mapOf<String, PublicKeyEntry>().toMutableMap().apply {
            put("owner", PublicKeyEntry(
                    id = "$ownerDID#owner",
                    type = PublicKeyType.Secp256k1VerificationKey2018,
                    owner = ownerDID,
                    ethereumAddress = ownerAddress
            ))

        }
        val authEntries = mapOf<String, AuthenticationEntry>().toMutableMap().apply {
            put("owner", AuthenticationEntry(
                    type = PublicKeyType.Secp256k1SignatureAuthentication2018,
                    publicKey = "$ownerDID#owner"
            ))
        }
        val serviceEntries = mapOf<String, ServiceEntry>().toMutableMap()

        var delegateCount = 0

        history.forEach { event ->
            when (event) {
                is DIDDelegateChanged.Arguments -> {
                    val (pk, auth) = processDelegateChanged(event, delegateCount, ownerDID)
                    pkEntries.putAll(pk)
                    authEntries.putAll(auth)
                    delegateCount += pk.size
                }

                is DIDAttributeChanged.Arguments -> {
                    val (pk, services) = processAttributeChanged(event, delegateCount, ownerDID)
                    pkEntries.putAll(pk)
                    serviceEntries.putAll(services)
                    delegateCount += pk.size
                }
            }
        }

        return EthrDIDDocument(
                id = ownerDID,
                publicKey = pkEntries.values.toList(),
                authentication = authEntries.values.toList(),
                service = serviceEntries.values.toList()
        )
    }

    private fun processAttributeChanged(
            event: DIDAttributeChanged.Arguments,
            delegateCount: Int,
            normalizedDid: String
    ): Pair<Map<String, PublicKeyEntry>, Map<String, ServiceEntry>> {
        val pkEntries = mapOf<String, PublicKeyEntry>().toMutableMap()
        val serviceEntries = mapOf<String, ServiceEntry>().toMutableMap()

        var delegateIndex = delegateCount
        val validTo = event.validto.value.toLong()
        if (validTo < timeProvider.nowMs() / 1000L) {
            return (pkEntries to serviceEntries)
        }
        val name = event.name.byteArray.bytes32ToString()
        val key = "DIDAttributeChanged-$name-${event.value.items.toHexString()}"

        //language=RegExp
        val regex = """^did/(pub|auth|svc)/(\w+)(/(\w+))?(/(\w+))?$""".toRegex()
        val matchResult = regex.matchEntire(name)
                ?: return (pkEntries to serviceEntries)
        val (section, algo, _, rawType, _, encoding)
                = matchResult.destructured
        val type = parseType(algo, rawType)

        when (section) {

            "pub" -> {
                delegateIndex++
                val pk = PublicKeyEntry(
                        id = "$normalizedDid#delegate-$delegateIndex",
                        type = type,
                        owner = normalizedDid)

                pkEntries[key] = when (encoding) {
                    "", "null", "hex" ->
                        pk.copy(publicKeyHex = event.value.items.toHexString())
                    "base64" ->
                        pk.copy(publicKeyBase64 = event.value.items.toBase64())
                    "base58" ->
                        pk.copy(publicKeyBase58 = event.value.items.toString(utf8).hexToByteArray().encodeToBase58String())
                    else ->
                        pk.copy(value = event.value.items.toHexString())
                }

            }

            "svc" -> {
                serviceEntries[key] = ServiceEntry(
                        type = algo,
                        serviceEndpoint = event.value.items.toString(utf8)
                )
            }
        }
        return (pkEntries to serviceEntries)
    }

    @Suppress("StringLiteralDuplication")
    private fun processDelegateChanged(event: DIDDelegateChanged.Arguments, delegateCount: Int, ownerDID: String):
            Pair<MutableMap<String, PublicKeyEntry>, MutableMap<String, AuthenticationEntry>> {

        val pkEntries = mapOf<String, PublicKeyEntry>().toMutableMap()
        val authEntries = mapOf<String, AuthenticationEntry>().toMutableMap()

        var delegateIndex = delegateCount
        val delegateType = event.delegatetype.bytes.toString(utf8)
        val delegate = event.delegate.value.toHexStringNoPrefix().prepend0xPrefix()
        val key = "DIDDelegateChanged-$delegateType-$delegate"
        val validTo = event.validto.value.toLong()

        if (validTo >= timeProvider.nowMs() / 1000L) {
            delegateIndex++

            when (delegateType) {
                Secp256k1SignatureAuthentication2018.name,
                sigAuth -> authEntries[key] = AuthenticationEntry(
                        type = Secp256k1SignatureAuthentication2018,
                        publicKey = "$ownerDID#delegate-$delegateIndex")

                Secp256k1VerificationKey2018.name,
                veriKey -> pkEntries[key] = PublicKeyEntry(
                        id = "$ownerDID#delegate-$delegateIndex",
                        type = Secp256k1VerificationKey2018,
                        owner = ownerDID,
                        ethereumAddress = delegate)
            }
        }
        return (pkEntries to authEntries)
    }

    companion object {
        const val DEFAULT_REGISTRY_ADDRESS = "0xdca7ef03e98e0dc2b855be647c39abe984fcf21b"

        internal const val veriKey = "veriKey"
        internal const val sigAuth = "sigAuth"

        private val attrTypes = mapOf(
                sigAuth to "SignatureAuthentication2018",
                veriKey to "VerificationKey2018"
        )

        private fun parseType(algo: String, rawType: String): PublicKeyType {
            var type = if (rawType.isBlank()) veriKey else rawType
            type = attrTypes[type] ?: type
            return PublicKeyType("$algo$type") //will throw exception if none found
        }

        //language=RegExp
        val identityExtractPattern = "^did:ethr:(0x[0-9a-fA-F]{40})".toRegex()

        //language=RegExp
        private val didParsePattern = "^(did:)?((\\w+):)?((0x)([0-9a-fA-F]{40}))".toRegex()

        @VisibleForTesting(otherwise = PRIVATE)
        private fun parseIdentity(normalizedDid: String) = identityExtractPattern
                .find(normalizedDid)
                ?.destructured?.component1() ?: ""

        @VisibleForTesting(otherwise = PRIVATE)
        fun normalizeDid(did: String): String {
            val matchResult = didParsePattern.find(did) ?: return ""
            val (didHeader, _, didType, _, _, hexDigits) = matchResult.destructured
            if (didType.isNotBlank() && didType != "ethr") {
                //should forward to another resolver
                return ""
            }
            if (didHeader.isBlank() && didType.isNotBlank()) {
                //doesn't really look like a did if it only specifies type and not "did:"
                return ""
            }
            return "did:ethr:0x$hexDigits"
        }

    }
}
